## Answers

#### Answer 1

Какой самый эффективный способ конкатенации строк?


Самый эффективный способ конкатенации строк - это Builder из пакета strings.



#### Answer 2

Что такое интерфейсы, как они применяются в Go?


Интерфейс - это инструмент языка, который позволяет определить набор поведений для той или иной абстракции. 

Интерфейсы позволяют реализовать ООП парадигму - полиморфизм.



#### Answer 3

Чем отличаются RWMutex от Mutex?


Для обычного мьютекса нет разницы между доступом для чтения и записью. RWMutex же позволяет разделить писателей и читателей, что способствует созданию конкурентности между горутинами.



#### Answer 4

Чем отличаются буферизированные и не буферизированные каналы?


Количеством хранимых элементов. 

Так в буферизированном канале может храниться n-ое количество элементов. При этом структура данных будет соответствовать очереди.



#### Answer 5

Какой размер у структуры struct{}{}?


Нулевой.



#### Answer 6

Есть ли в Go перегрузка методов или операторов?


Нет. 



#### Answer 7

В какой последовательности будут выведены элементы map[int]int?

Пример:

```bash
m[0]=1
m[1]=124
m[2]=281
```


Элементы будут выведены в случайной последовательности. Это объясняется тем, что мапа не гарантирует порядок элементов. 



#### Answer 8

В чем разница make и new?


Функция new просто аллоцирует память в куче для той или иной переменной. Make же в свою очередь еще и инициализирует переменную начальным значением в соответствии с ее типом. 
При этом важно помнить, что make работает только с тремя типами: слайс, мапа и канал. 



#### Answer 9

Сколько существует способов задать переменную типа slice или map?


Существует 4 способоа задания slice или map



#### Answer 10

Что выведет данная программа и почему?

```bash
func update(p *int) {
  b := 2
  p = &b
}

func main() {
  var (
     a = 1
     p = &a
  )
  fmt.Println(*p)
  update(p)
  fmt.Println(*p)
}
```


Программа выведет две единицы, т.к. при передаче указателя в аргументы функции, создастся новая переменная, указывающая на ту же ячейку памяти, что и оригинальный поинтер.



#### Answer 11

Что выведет данная программа и почему?

```bash
func main() {
  wg := sync.WaitGroup{}
  for i := 0; i < 5; i++ {
     wg.Add(1)
     go func(wg sync.WaitGroup, i int) {
        fmt.Println(i)
        wg.Done()
     }(wg, i)
  }
  wg.Wait()
  fmt.Println("exit")
}
```


Программа выкинет дед лок, т.к. передача группы ожидание происходит по значению. 



#### Answer 12

Что выведет данная программа и почему?

```bash
func main() {
  n := 0
  if true {
     n := 1
     n++
  }
  fmt.Println(n)
}
```


Программа выведет 0, т.к. различные области видимости. 



#### Answer 13

Что выведет данная программа и почему?

```bash
func someAction(v []int8, b int8) {
  v[0] = 100
  v = append(v, b)
}

func main() {
  var a = []int8{1, 2, 3, 4, 5}
  someAction(a, 6)
  fmt.Println(a)
}
```


Программа выведет тот же массив a с единственным различием: первый элемент будет являться 100. Объяснение аналогично 10 пункту. 



#### Answer 14

Что выведет данная программа и почему?

```bash
func main() {
  slice := []string{"a", "a"}

  func(slice []string) {
     slice = append(slice, "a")
     slice[0] = "b"
     slice[1] = "b"
     fmt.Print(slice)
  }(slice)
  fmt.Print(slice)
}
```


Программа выведет: [b, b, a] \n [a, a], т.к. передача слайса в анонимную функцию происходит через параметры этой функции. 
